/*
Scrolling text display for YFRobot 8x8 Dot Matrix display (controller with dual serial 74HC595 chips)
Author: Andy Qua
Date: 26th April 2015
*/

int dataPin = 11;             // The Serial Data Pin to the Shift Register (SER on board)
int latchPin = 12;             // The Latch Pin to the Shift Register (RCK on board)
int clockPin = 10;             // The Clock Pin to the Shift Register (SRCK on board)

/*
Letters are 8x6 bytes and are in vertical rows
E.g. for A:
  column 1 -> 0x7f = 01111111      Rotated:    XXX
  column 2 -> 0x88 = 10001000                 X   X
  column 3 -> 0x88 = 10001000                 X   X
  column 4 -> 0x88 = 10001000                 X   X
  column 5 -> 0x7f = 01111111                 XXXXX
  column 6 -> 0x00 = 00000000                 X   X
                                              X   X  
                                              X   X  

for B:
  column 1 -> 0xFF = 11111111      Rotated:   XXXX
  column 2 -> 0x91 = 10010001                 X   X
  column 2 -> 0x91 = 10010001                 X   X
  column 2 -> 0x91 = 10010001                 X   X
  column 5 -> 0x6e = 01101110                 XXXX
  column 6 -> 0x00 = 00000000                 X   X
                                              X   X  
                                              XXXX
*/

// Basic alphabet
byte letters[][6] = {
  { 0x7F, 0x88, 0x88, 0x88, 0x7F, 0x00}, //  A
  { 0xFF, 0x91, 0x91, 0x91, 0x6E, 0x00}, //  B
  { 0x7E, 0x81, 0x81, 0x81, 0x42, 0x00}, //  C
  { 0xFF, 0x81, 0x81, 0x42, 0x3C, 0x00}, //  D
  { 0xFF, 0x91, 0x91, 0x91, 0x81, 0x00}, //  E
  { 0xFF, 0x90, 0x90, 0x90, 0x80, 0x00}, //  F
  { 0x7E, 0x81, 0x89, 0x89, 0x4E, 0x00}, //  G
  { 0xFF, 0x10, 0x10, 0x10, 0xFF, 0x00}, //  H
  { 0x81, 0x81, 0xFF, 0x81, 0x81, 0x00}, //  I
  { 0x06, 0x01, 0x01, 0x01, 0xFE, 0x00}, //  J
  { 0xFF, 0x18, 0x24, 0x42, 0x81, 0x00}, //  K
  { 0xFF, 0x01, 0x01, 0x01, 0x01, 0x00}, //  L
  { 0xFF, 0x40, 0x30, 0x40, 0xFF, 0x00}, //  M
  { 0xFF, 0x40, 0x30, 0x08, 0xFF, 0x00}, //  N
  { 0x7E, 0x81, 0x81, 0x81, 0x7E, 0x00}, //  O
  { 0xFF, 0x88, 0x88, 0x88, 0x70, 0x00}, //  P
  { 0x7E, 0x81, 0x85, 0x82, 0x7D, 0x00}, //  Q
  { 0xFF, 0x88, 0x8C, 0x8A, 0x71, 0x00}, //  R
  { 0x61, 0x91, 0x91, 0x91, 0x8E, 0x00}, //  S
  { 0x80, 0x80, 0xFF, 0x80, 0x80, 0x00}, //  T
  { 0xFE, 0x01, 0x01, 0x01, 0xFE, 0x00}, //  U
  { 0xF0, 0x0C, 0x03, 0x0C, 0xF0, 0x00}, //  V
  { 0xFF, 0x02, 0x0C, 0x02, 0xFF, 0x00}, //  W
  { 0xC3, 0x24, 0x18, 0x24, 0xC3, 0x00}, //  X
  { 0xE0, 0x10, 0x0F, 0x10, 0xE0, 0x00}, //  Y
  { 0x83, 0x85, 0x99, 0xA1, 0xC1, 0x00}, //  Z
  { 0x06, 0x29, 0x29, 0x29, 0x1F, 0x00}, //  a
  { 0xFF, 0x09, 0x11, 0x11, 0x0E, 0x00}, //  b
  { 0x1E, 0x21, 0x21, 0x21, 0x12, 0x00}, //  c
  { 0x0E, 0x11, 0x11, 0x09, 0xFF, 0x00}, //  d
  { 0x0E, 0x15, 0x15, 0x15, 0x0C, 0x00}, //  e
  { 0x08, 0x7F, 0x88, 0x80, 0x40, 0x00}, //  f
  { 0x30, 0x49, 0x49, 0x49, 0x7E, 0x00}, //  g
  { 0xFF, 0x08, 0x10, 0x10, 0x0F, 0x00}, //  h
  { 0x00, 0x00, 0x5F, 0x00, 0x00, 0x00}, //  i
  { 0x02, 0x01, 0x21, 0xBE, 0x00, 0x00}, //  j
  { 0xFF, 0x04, 0x0A, 0x11, 0x00, 0x00}, //  k
  { 0x00, 0x81, 0xFF, 0x01, 0x00, 0x00}, //  l
  { 0x3F, 0x20, 0x18, 0x20, 0x1F, 0x00}, //  m
  { 0x3F, 0x10, 0x20, 0x20, 0x1F, 0x00}, //  n
  { 0x0E, 0x11, 0x11, 0x11, 0x0E, 0x00}, //  o
  { 0x3F, 0x24, 0x24, 0x24, 0x18, 0x00}, //  p
  { 0x10, 0x28, 0x28, 0x18, 0x3F, 0x00}, //  q
  { 0x1F, 0x08, 0x10, 0x10, 0x08, 0x00}, //  r
  { 0x09, 0x15, 0x15, 0x15, 0x02, 0x00}, //  s
  { 0x20, 0xFE, 0x21, 0x01, 0x02, 0x00}, //  t
  { 0x1E, 0x01, 0x01, 0x02, 0x1F, 0x00}, //  u
  { 0x1C, 0x02, 0x01, 0x02, 0x1C, 0x00}, //  v
  { 0x1E, 0x01, 0x0E, 0x01, 0x1E, 0x00}, //  w
  { 0x11, 0x0A, 0x04, 0x0A, 0x11, 0x00}, //  x
  { 0x00, 0x39, 0x05, 0x05, 0x3E, 0x00}, //  y
  { 0x11, 0x13, 0x15, 0x19, 0x11, 0x00}, //  z
  { 0x00, 0x41, 0xFF, 0x01, 0x00, 0x00}, //  1
  { 0x43, 0x85, 0x89, 0x91, 0x61, 0x00}, //  2
  { 0x42, 0x81, 0x91, 0x91, 0x6E, 0x00}, //  3
  { 0x18, 0x28, 0x48, 0xFF, 0x08, 0x00}, //  4
  { 0xF2, 0x91, 0x91, 0x91, 0x8E, 0x00}, //  5
  { 0x1E, 0x29, 0x49, 0x89, 0x86, 0x00}, //  6
  { 0x80, 0x8F, 0x90, 0xA0, 0xC0, 0x00}, //  7
  { 0x6E, 0x91, 0x91, 0x91, 0x6E, 0x00}, //  8
  { 0x70, 0x89, 0x89, 0x8A, 0x7C, 0x00}, //  9
  { 0x7E, 0x89, 0x91, 0xA1, 0x7E, 0x00}, //  0
  { 0x60, 0x80, 0x8D, 0x90, 0x60, 0x00}, //  ?
  { 0x00, 0x00, 0xFD, 0x00, 0x00, 0x00}, //  !
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00} // SPACE
};

// character to letter mapping
String letterPositions = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890?! ";

// The database for the text to scroll
byte *textBytes;
int nrLetters = 0;
int columnNumbers[8] = { 1, 2, 4,5,6,7,8 };


void setup()
{
  pinMode(dataPin, OUTPUT);    // Configure Digital Pins
  pinMode(latchPin, OUTPUT);
  pinMode(clockPin, OUTPUT);

  // Text = Hello from AndyQ
  loadString( " Hello from AndyQ  This text scrolls!  " );
}

void loadString( String text )
{
  // Build up byte array
  nrLetters = text.length();
  
  // Allocate memory for byte array
  textBytes = (byte *)malloc(nrLetters * 6 * sizeof(byte));
  int pos = 0;
  for ( int i = 0 ; i < nrLetters ; ++i )
  {
    int chPos = letterPositions.indexOf( text[i] );
    if ( chPos == -1 )
      continue;

    for ( int j = 0 ; j < 6 ; ++j )
    {
      textBytes[pos++] = letters[chPos][j];
    }

  }
}

void loop()
{
  for ( int p = 0 ; p < (nrLetters * 6) ; p++ )
  {
    int columnVal = 0;
    
    // Change repeat to vary the speed of the scrolling text
    for (int repeat = 0; repeat < 50; repeat++ )
    {
      for ( int col = 0 ; col < 8 ; ++col )
      {
        columnVal = textBytes[p + col];
        
        // For some reason, columnNumbers are set sanely (e.g. 1,2,4,8,16,32,64,128)
        // BUT the column values are inverted - so a 1 means off and a 0 is on!
        // so we invert the bits in the rowVal.
        writeOutput(~columnVal, columnNumbers[col]);
      }
    }
  }
}


void writeOutput( int rowVal, int col  )
{
  digitalWrite(latchPin, LOW);                    // Pull latch LOW to send data
  shiftOut(dataPin, clockPin, MSBFIRST, rowVal);  // Send the row data byte
  shiftOut(dataPin, clockPin, MSBFIRST, col);     // Send the column data byte
  digitalWrite(latchPin, HIGH);                   // Pull latch HIGH to finish sending data
}
